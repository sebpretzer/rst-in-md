{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"rst-in-md","text":"<p><code>rst-in-md</code> is a simple tool to convert reStructuredText within Markdown, built to extend Python Markdown.</p> <ul> <li> Easy to use, no complex setup required</li> <li> Supports many reStructuredText elements</li> <li> Integrates with MkDocs</li> <li> Integrates with PyMdown Extensions</li> </ul> <p>Turn this:</p> markdown.md<pre><code>   ```rst\n   +------------------------+------------+----------+----------+\n   | Header row, column 1   | Header 2   | Header 3 | Header 4 |\n   | (header rows optional) |            |          |          |\n   +========================+============+==========+==========+\n   | body row 1, column 1   | column 2   | column 3 | column 4 |\n   +------------------------+------------+----------+----------+\n   | body row 2             | Cells may span columns.          |\n   +------------------------+------------+---------------------+\n   | body row 3             | Cells may  | - Table cells       |\n   +------------------------+ span rows. | - contain           |\n   | body row 4             |            | - body elements.    |\n   +------------------------+------------+---------------------+\n   ```\n</code></pre> <p>Into this:           Header row, column 1 (header rows optional)                 Header 2                 Header 3                 Header 4                 body row 1, column 1                 column 2                 column 3                 column 4                 body row 2                 Cells may span columns.                 body row 3                 Cells may span rows.        <ul> <li>             Table cells           </li> <li>             contain           </li> <li>             body elements.           </li> </ul>          body row 4        </p> <p>To get started, please head to installation guide.</p> <p>To understand how this tool works, you can read more about the implementation.</p>"},{"location":"explanations/implementation/","title":"Implementation","text":""},{"location":"explanations/implementation/#fenced-code-blocks","title":"Fenced Code Blocks","text":"<p>The general goal is to make it as easy as possible to make current Markdown files compatible with this tool. With that in mind, <code>rst-in-md</code> will convert all fenced code blocks with the <code>rst</code> language identifier to html as reStructuredText. This is a similar approach to how MkDocs-Material handles mermaid diagrams.</p> <p>To make sure that the tool properly finds the code blocks, it has to run before the FencedBlockPreprocessor in the Python Markdown pipeline. This is done by setting the <code>rst-in-md</code> extension to be a higher priority than the <code>fenced_code_block</code> extension.</p> <p>See general usage for examples.</p>"},{"location":"explanations/implementation/#integration-with-pymdown-extensions-superfences","title":"Integration with PyMdown Extensions SuperFences","text":"<p><code>rst-in-md</code> is designed to work with PyMdown Extensions SuperFences. The SuperFences extension is for the most part superior to the default fenced code block implementation. The SuperFences API allows for custom fences, like this one.</p> <p>Usually, <code>pymdownx.superfences</code> require custom fences to be specified. However, <code>rst-in-md</code> automatically detects that <code>pymdownx.superfences</code> is installed and will properly handle the configuration for you. You can find that implemenation in the auto-configuration reference.</p>"},{"location":"explanations/implementation/#stripped-html-tags","title":"Stripped HTML Tags","text":"<p>Certain html tags generated by <code>rst-in-md</code> will be stripped out in order to attempt to provide loose parity to the <code>Python Markdown</code> output. This is done to prevent downstream code from breaking due to the differences in the output. For example, the <code>class</code> attribute is stripped because it can break the MkDocs-Material theme.</p>"},{"location":"explanations/implementation/#inline-ignore","title":"Inline Ignore","text":"<p>While using fenced code blocks is the least intrusive way to use <code>rst-in-md</code>, it may not always be the intended behavior to convert a particular code block. To prevent this, you can add a flag attribute to the code block you do not wish to convert.</p> <p>This is only disables the conversion of the following code block, rather that the rest of the file, etc. The expectation is that if the user is using this tool, they want to convert the majority of the reStructuredText in their repository, so an opt-out mechanism is more appropriate.</p> <p>See inline ignore for examples.</p>"},{"location":"explanations/implementation/#graceful-failures","title":"Graceful Failures","text":"<p><code>rst-in-md</code> is designed to fail gracefully. If there is an error in the parsing of the reStructuredText, the tool will warn the user and fall back to standard Markdown rendering. This is used to prevent the tool from getting in the way of the user's workflow and is similar to how pymdown-extensions handles errors.</p>"},{"location":"explanations/limitations/","title":"Limitations","text":""},{"location":"explanations/limitations/#unstable","title":"Unstable","text":"<p>The current implementation is unstable and may not work as expected. It has only been tested on a handful of test cases and may not work with all <code>reStructuredText</code> types.</p> <p>To see the current tested types, please refer to the <code>tests/compatibility/rst/</code> directory.</p>"},{"location":"explanations/limitations/#loose-parity","title":"Loose Parity","text":"<p>There is no guarantee that the output of <code>rst-in-md</code> will produce identical html output as <code>Python-Markdown</code>. The goal is to produce as close a result as possible, so that downstream code any better format rst-based html, but there may be differences. Some of these differences are on purpose, to extend the functionality, while others are due to limitations in the current implementation. This will break something like the class directive, which is stripped out.</p>"},{"location":"explanations/limitations/#no-support-for-rst-files","title":"No support for <code>.rst</code> files","text":"<p><code>rst-in-md</code> is designed to work with <code>reStructuredText</code> code blocks within <code>Markdown</code> files. It does not support <code>.rst</code> files directly. If you want to convert <code>.rst</code> files to <code>.md</code> files, you will need to use a different tool.</p>"},{"location":"explanations/motivation/","title":"Motivation","text":"<p>The goal of Markdown is to provide an easy-to-read, easy-to-write plain text format that can be converted into HTML. It is designed to be as simple as possible, while still providing a rich set of features. Python-Markdown provides an excellent implementation of the Markdown spec, and it has near parity.</p> <p>But the issue is that the Markdown specification is not as rich as it could be. There are many features that are not supported, and many tools have extended the functionality where they see fit, chief among them being PyMdown Extensions. The goal of <code>rst-in-md</code> is to further extend those capabilities, and provide an even richer set of features, where functionality is lacking.</p> <p>reStructuredText has a similar philosophy to Markdown, as it attempts to be easy-to-read and easy-to-write. Markdown is still superior on that front, but what it lacks in readability it makes up for in its rich feature set. It is extremely popular in the python community, meaning it is relatively robust and dependable. And there should be a lot of examples for users to draw from. Providing a way to embed <code>reStructuredText</code> in Markdown, and have it render as expected, can provide a lot of value to users.</p>"},{"location":"guides/general_usage/","title":"General Usage","text":"<p>After installing the package, any fenced code block with the language <code>rst</code> will be converted to <code>reStructuredText</code> by the <code>rst-in-md</code> tool.</p>"},{"location":"guides/general_usage/#basic-example","title":"Basic Example","text":"<p>For example, this markdown: markdown.md<pre><code>    ```rst\n    .. table:: Truth table for \"not\"\n       :widths: auto\n\n       =====  =====\n           A    not A\n       =====  =====\n       False  True\n       True   False\n       =====  =====\n    ```\n</code></pre></p> <p>Will be converted to this <code>reStructuredText</code>:       Truth table for \"not\"             A                 not A                 False                 True                 True                 False        </p> <p>Note</p> <p>This will work for any short names that are used for the <code>reStructuredText</code> language identifier:</p> <ul> <li><code>rst</code></li> <li><code>restructuredtext</code></li> <li><code>rest</code></li> </ul> <p>For example, you can replace <code>```rst</code> with <code>```rest</code> or <code>```restructuredtext</code></p> <p>You can also ignore specific code blocks if you want them rendered the normal way.</p>"},{"location":"guides/general_usage/#supported-features","title":"Supported Features","text":"<p><code>reStructuredText</code> is a powerful markup language that can be used to create a lot of complex structures. This includes directives like tables, images, etc. This also includes some latex math support, which can be used to render equations.</p> <p>The <code>rst-in-md</code> tool officially supports just a small subset of the features that <code>reStructuredText</code> provides, since a lot of them are redundant when used within a Markdown document.</p> <p>Below are some of the features that are supported.</p>"},{"location":"guides/general_usage/#simple-tables","title":"Simple Tables","text":"markdown.md<pre><code>    ```rst\n    =====  =====\n    A      B\n    =====  =====\n    False  False\n    True   False\n    False  True\n    True   True\n    =====  =====\n    ```\n</code></pre>          A                 B                 False                 False                 True                 False                 False                 True                 True                 True"},{"location":"guides/general_usage/#grid-tables","title":"Grid Tables","text":"markdown.md<pre><code>    ```rst\n    +------------------------+------------+----------+----------+\n    | Header row, column 1   | Header 2   | Header 3 | Header 4 |\n    | (header rows optional) |            |          |          |\n    +========================+============+==========+==========+\n    | body row 1, column 1   | column 2   | column 3 | column 4 |\n    +------------------------+------------+----------+----------+\n    | body row 2             | Cells may span columns.          |\n    +------------------------+------------+---------------------+\n    | body row 3             | Cells may  | - Table cells       |\n    +------------------------+ span rows. | - contain           |\n    | body row 4             |            | - body elements.    |\n    +------------------------+------------+---------------------+\n    ```\n</code></pre>          Header row, column 1 (header rows optional)                 Header 2                 Header 3                 Header 4                 body row 1, column 1                 column 2                 column 3                 column 4                 body row 2                 Cells may span columns.                 body row 3                 Cells may span rows.        <ul> <li>             Table cells           </li> <li>             contain           </li> <li>             body elements.           </li> </ul>          body row 4"},{"location":"guides/general_usage/#list-tables","title":"List Tables","text":"markdown.md<pre><code>    ```rst\n    .. list-table:: Title\n       :widths: 25 25 50\n       :header-rows: 1\n\n       * - Heading row 1, column 1\n         - Heading row 1, column 2\n         - Heading row 1, column 3\n       * - Row 1, column 1\n         -\n         - Row 1, column 3\n       * - Row 2, column 1\n         - Row 2, column 2\n         - Row 2, column 3\n    ```\n</code></pre>      Title             Heading row 1, column 1                 Heading row 1, column 2                 Heading row 1, column 3                 Row 1, column 1                 Row 1, column 3                 Row 2, column 1                 Row 2, column 2                 Row 2, column 3"},{"location":"guides/general_usage/#latex-math-support","title":"Latex math support","text":"markdown.md<pre><code>    ```rst\n    .. math::\n\n       \\int_{-\\infty}^\\infty e^{-x^2} dx = \\sqrt{\\pi}\n    ```\n</code></pre> <sup>       \u221e     </sup>          \u222b        <sub>       \u2212\u2009\u221e     </sub>      e    <sup>     \u2212            x      <sup>       2     </sup> </sup>      dx      =           \u221a             (               \u03c0               )"},{"location":"guides/inline_ignore/","title":"Inline Ignore","text":"<p>To use the inline ignore feature, add an attribute to the code block you do not wish to convert like so: <code>```{.rst rst-in-md=false}</code>. This will prevent the <code>rst-in-md</code> tool from converting the fenced code block directly following the comment.</p> <p>Bare in mind, you will need to add a comment for each code block you want to ignore. To understand why it was implemented this way, check out the implementation guide.</p>"},{"location":"guides/inline_ignore/#ignore-conversion","title":"Ignore conversion","text":"<p>How the ignore attribute works:</p>"},{"location":"guides/inline_ignore/#before","title":"Before","text":"ignore.md<pre><code>    ```{.rst rst-in-md=false}\n    With this comment, this will be ignored by the `rst-in-md` tool.\n    ```\n</code></pre>"},{"location":"guides/inline_ignore/#after","title":"After","text":"<pre><code>With this comment, this will be ignored by the `rst-in-md` tool.\n</code></pre>"},{"location":"guides/inline_ignore/#with-conversion","title":"With conversion","text":""},{"location":"guides/inline_ignore/#before_1","title":"Before","text":"normal.md<pre><code>    ```rst\n    This will be converted by the `rst-in-md` tool.\n    ```\n</code></pre>"},{"location":"guides/inline_ignore/#after_1","title":"After","text":"<p>   This will be converted by the        rst-in-md      tool. </p>"},{"location":"guides/installation/","title":"Installation","text":""},{"location":"guides/installation/#from-pypi","title":"From PyPI","text":"<p>Install <code>rst-in-md</code> using PyPI:</p> <p><pre><code>pip install rst-in-md\n</code></pre> or <pre><code>uv add rst-in-md\n</code></pre></p>"},{"location":"guides/installation/#from-source","title":"From Source","text":"<p>If you want to manually install it, run:</p> <p><pre><code>uv run hatchling build\n</code></pre> and then install the wheel file generated in the <code>dist/</code> directory.</p>"},{"location":"guides/installation/#locally","title":"Locally","text":"<p>If you want to use it locally, you can clone the repository and run:</p> <pre><code>uv add . --editable\n</code></pre> <p>Now you can use the extension in your markdown files.</p>"},{"location":"guides/integrations/","title":"Integrations","text":""},{"location":"guides/integrations/#mkdocs","title":"MkDocs","text":"<p>To integrate with MkDocs, you simply need to make sure <code>rst-in-md</code> is installed and then add the following to your <code>mkdocs.yml</code> file:</p> <pre><code>markdown_extensions:\n  - attr_list\n  - rst_in_md\n</code></pre>"},{"location":"guides/integrations/#pymdown-extensions-superfences","title":"PyMdown Extensions SuperFences","text":"<p>The SuperFences extension overrides the default code block behavior in Python Markdown. To make sure <code>rst-in-md</code> is properly called, you simply need to specify the extension <code>pymdownx.superfences</code>:</p> <pre><code>markdown_extensions:\n  - attr_list\n  - rst_in_md\n  - pymdownx.superfences\n</code></pre> <p>You can read more about this integration in the explanation and reference.</p> <p>Auto-Configuration</p> <p>By installing both <code>rst-in-md</code> and <code>pymdownx.superfences</code>, you invoke an auto-configurator that will remove <code>rst-in-md</code> and add the proper <code>custom_fences</code> for <code>pymdownx.superfences</code>. It is equivalent to the following configuration:</p> <pre><code>markdown_extensions:\n  - attr_list\n- - rst_in_md\n  - pymdownx.superfences:\n+     custom_fences:\n+       - name: rst\n+         class: rst-in-md\n+         format: !!python/name:rst_in_md.superfence_formatter\n+        validate: !!python/name:rst_in_md.superfence_validator\n+       - name: rest\n+         class: rst-in-md\n+         format: !!python/name:rst_in_md.superfence_formatter\n+         validate: !!python/name:rst_in_md.superfence_validator\n+       - name: restructuredtext\n+         class: rst-in-md\n+         format: !!python/name:rst_in_md.superfence_formatter\n+         validate: !!python/name:rst_in_md.superfence_validator\n</code></pre> <p>If you want to customize the <code>custom_fences</code>, you can do so by simply not including <code>rst-in-md</code> in the <code>markdown_extensions</code> and specifying the <code>custom_fences</code> yourself.</p> <p>The auto-configurator will work with other custom fences like <code>mermaid.js</code> as well, so only do this if you want to customize the <code>rst-in-md</code> superfences in particular.</p>"},{"location":"reference/conversion/","title":"Conversion","text":""},{"location":"reference/conversion/#rst_in_md.rst_to_soup","title":"<code>rst_in_md.rst_to_soup(rst)</code>","text":"<p>Convert restructured text to html in a manner that is compatible with markdown.</p> <p>Parameters:</p> Name Type Description Default <code>rst</code> <code>str</code> <p>Raw restructured text to convert to html.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>BeautifulSoup</code> <p>Html converted from restructured text.</p> Source code in <code>rst_in_md/conversion.py</code> <pre><code>def rst_to_soup(rst: str) -&gt; BeautifulSoup:\n    \"\"\"Convert restructured text to html in a manner that is compatible with markdown.\n\n    Args:\n        rst (str): Raw restructured text to convert to html.\n\n    Returns:\n        str: Html converted from restructured text.\n    \"\"\"\n    soup = _rst_to_soup(rst)\n    return _strip_attributes(soup)\n</code></pre>"},{"location":"reference/conversion/#rst_in_md.conversion._rst_to_soup","title":"<code>rst_in_md.conversion._rst_to_soup(rst)</code>","text":"<p>Convert reStructuredText to a BeautifulSoup object.</p> <p>This will convert the reStructuredText to HTML using docutils. The HTML is then converted to a BeautifulSoup object and returned.</p> <p>Errors and warnings are captured gracefully and raised at the end.</p> <p>This function is heavily inspired by this rst2html implementation.</p> <p>Parameters:</p> Name Type Description Default <code>rst</code> <code>str</code> <p>The reStructuredText to convert.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If there are any errors or warnings during the conversion.</p> <p>Returns:</p> Name Type Description <code>BeautifulSoup</code> <code>BeautifulSoup</code> <p>The converted reStructuredText.</p> Source code in <code>rst_in_md/conversion.py</code> <pre><code>def _rst_to_soup(rst: str) -&gt; BeautifulSoup:\n    \"\"\"Convert reStructuredText to a BeautifulSoup object.\n\n    This will convert the reStructuredText to HTML using docutils. The HTML is then\n    converted to a BeautifulSoup object and returned.\n\n    Errors and warnings are captured gracefully and raised at the end.\n\n    This function is heavily inspired by this [rst2html](https://github.com/andrewpetrochenkov/rst2html.py/blob/b66942f16e93d7260748ecc90867c55a4bb3236d/rst2html/__init__.py)\n    implementation.\n\n    Args:\n        rst (str): The reStructuredText to convert.\n\n    Raises:\n        ValueError: If there are any errors or warnings during the conversion.\n\n    Returns:\n        BeautifulSoup: The converted reStructuredText.\n    \"\"\"\n    kwargs = {\n        \"writer_name\": \"html\",\n        \"settings_overrides\": {\n            \"_disable_config\": True,\n            \"report_level\": 2,\n        },\n    }\n\n    with io.StringIO() as target, redirect_stderr(target):\n        parts = docutils.core.publish_parts(rst, **kwargs)\n        warning = target.getvalue().strip()\n\n    if warning:\n        msg = f\"Failed to convert restructured text:\\n\\n{warning}\"\n        raise ValueError(msg)\n\n    return BeautifulSoup(parts.get(\"body\"), features=\"html.parser\")\n</code></pre>"},{"location":"reference/conversion/#rst_in_md.conversion._strip_attributes","title":"<code>rst_in_md.conversion._strip_attributes(soup)</code>","text":"<p>Remove specific attributes from the soup.</p> <p>This will remove all attributes from the top level tags, and will also remove some attributes from the descendants. This took heavy inspiration from this StackOverflow answer.</p> <p>Parameters:</p> Name Type Description Default <code>soup</code> <code>BeautifulSoup</code> <p>Input soup to remove attributes from.</p> required <p>Returns:</p> Name Type Description <code>BeautifulSoup</code> <code>BeautifulSoup</code> <p>Same soup with attributes removed.</p> Source code in <code>rst_in_md/conversion.py</code> <pre><code>def _strip_attributes(soup: BeautifulSoup) -&gt; BeautifulSoup:\n    \"\"\"Remove specific attributes from the soup.\n\n    This will remove all attributes from the top level tags, and will also remove\n    some attributes from the descendants. This took heavy inspiration from this\n    [StackOverflow answer](https://stackoverflow.com/a/9045719).\n\n    Args:\n        soup (BeautifulSoup): Input soup to remove attributes from.\n\n    Returns:\n        BeautifulSoup: Same soup with attributes removed.\n    \"\"\"\n    # Remove attributes from the top level tags\n    for tag in soup.contents:\n        if isinstance(tag, Tag):\n            tag.attrs = {}\n\n    # Remove specific attributes from the descendants\n    for tag in soup.descendants:\n        if isinstance(tag, Tag):\n            tag.attrs = {\n                key: value\n                for key, value in tag.attrs.items()\n                if key not in ATTRIBUTES_TO_STRIP\n            }\n    return soup\n</code></pre>"},{"location":"reference/extension/","title":"Extension","text":"<p>Tip</p> <p>Reference for the Python-Markdown extension can be found here.</p>"},{"location":"reference/extension/#rst_in_md.RestructuredTextInMarkdown","title":"<code>rst_in_md.RestructuredTextInMarkdown</code>","text":"<p>               Bases: <code>Extension</code></p> <p>Extension to convert restructured text to html in markdown.</p> Source code in <code>rst_in_md/extension.py</code> <pre><code>class RestructuredTextInMarkdown(Extension):\n    \"\"\"Extension to convert restructured text to html in markdown.\"\"\"\n\n    @staticmethod\n    def _pymdownx_installed() -&gt; bool:\n        try:\n            import pymdownx.superfences  # noqa: F401\n        except ImportError:\n            return False\n        return True\n\n    def extendMarkdown(self, md: Markdown) -&gt; None:  # noqa: N802\n        \"\"\"Register the RestructuredTextInMarkdownPreProcessor.\n\n        Register the\n        [RestructuredTextInMarkdownPreProcessor](extension.md#rst_in_md.RestructuredTextInMarkdownPreProcessor)\n        with the markdown instance. This allows the preprocessor to be used when\n        markdown is rendered to html.\n\n        The priority of the preprocessor is set to `27`. This is higher than\n        the [fenced_code_block](https://github.com/Python-Markdown/markdown/blob/33359faa385f59b84cd87df5f4b0996055a482e2/markdown/extensions/fenced_code.py#L50)\n        preprocessor, so that `rst` blocks are processed beforehand. But it is\n        lower than [normalize_whitespace](https://github.com/Python-Markdown/markdown/blob/33359faa385f59b84cd87df5f4b0996055a482e2/markdown/preprocessors.py#L40)\n        so that the rst blocks can be processed in a similar manner to code blocks.\n\n        Also register the\n        [RestructuredTextInMarkdownAutoConfigurator](superfence.md#rst_in_md.RestructuredTextInMarkdownAutoConfigurator)\n        if `pymdownx.superfences` is installed.\n\n        Args:\n            md (Markdown): The Markdown instance.\n        \"\"\"\n        md.preprocessors.register(\n            RestructuredTextInMarkdownPreProcessor(md),\n            \"rst-in-md\",\n            27,\n        )\n\n        if self._pymdownx_installed():\n            md.preprocessors.register(\n                RestructuredTextInMarkdownAutoConfigurator(md),\n                \"rst-in-md-auto-configurator\",\n                300,\n            )\n</code></pre>"},{"location":"reference/extension/#rst_in_md.RestructuredTextInMarkdown.extendMarkdown","title":"<code>extendMarkdown(md)</code>","text":"<p>Register the RestructuredTextInMarkdownPreProcessor.</p> <p>Register the RestructuredTextInMarkdownPreProcessor with the markdown instance. This allows the preprocessor to be used when markdown is rendered to html.</p> <p>The priority of the preprocessor is set to <code>27</code>. This is higher than the fenced_code_block preprocessor, so that <code>rst</code> blocks are processed beforehand. But it is lower than normalize_whitespace so that the rst blocks can be processed in a similar manner to code blocks.</p> <p>Also register the RestructuredTextInMarkdownAutoConfigurator if <code>pymdownx.superfences</code> is installed.</p> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>Markdown</code> <p>The Markdown instance.</p> required Source code in <code>rst_in_md/extension.py</code> <pre><code>def extendMarkdown(self, md: Markdown) -&gt; None:  # noqa: N802\n    \"\"\"Register the RestructuredTextInMarkdownPreProcessor.\n\n    Register the\n    [RestructuredTextInMarkdownPreProcessor](extension.md#rst_in_md.RestructuredTextInMarkdownPreProcessor)\n    with the markdown instance. This allows the preprocessor to be used when\n    markdown is rendered to html.\n\n    The priority of the preprocessor is set to `27`. This is higher than\n    the [fenced_code_block](https://github.com/Python-Markdown/markdown/blob/33359faa385f59b84cd87df5f4b0996055a482e2/markdown/extensions/fenced_code.py#L50)\n    preprocessor, so that `rst` blocks are processed beforehand. But it is\n    lower than [normalize_whitespace](https://github.com/Python-Markdown/markdown/blob/33359faa385f59b84cd87df5f4b0996055a482e2/markdown/preprocessors.py#L40)\n    so that the rst blocks can be processed in a similar manner to code blocks.\n\n    Also register the\n    [RestructuredTextInMarkdownAutoConfigurator](superfence.md#rst_in_md.RestructuredTextInMarkdownAutoConfigurator)\n    if `pymdownx.superfences` is installed.\n\n    Args:\n        md (Markdown): The Markdown instance.\n    \"\"\"\n    md.preprocessors.register(\n        RestructuredTextInMarkdownPreProcessor(md),\n        \"rst-in-md\",\n        27,\n    )\n\n    if self._pymdownx_installed():\n        md.preprocessors.register(\n            RestructuredTextInMarkdownAutoConfigurator(md),\n            \"rst-in-md-auto-configurator\",\n            300,\n        )\n</code></pre>"},{"location":"reference/extension/#rst_in_md.RestructuredTextInMarkdownPreProcessor","title":"<code>rst_in_md.RestructuredTextInMarkdownPreProcessor</code>","text":"<p>               Bases: <code>Preprocessor</code></p> <p>Preprocessor to convert restructured text to html in markdown.</p> Source code in <code>rst_in_md/processor.py</code> <pre><code>class RestructuredTextInMarkdownPreProcessor(Preprocessor):\n    \"\"\"Preprocessor to convert restructured text to html in markdown.\"\"\"\n\n    _Processor = FencedBlockPreprocessor(Markdown(), {})\n    FENCED_BLOCK_RE = _Processor.FENCED_BLOCK_RE\n    handle_attrs = _Processor.handle_attrs\n\n    def run(self, lines: list[str]) -&gt; list[str]:\n        \"\"\"Strip restuctured text from markdown and replace it with converted html.\n\n        This method will look for fenced code blocks in markdown that are marked as\n        restructured text (`rst`, `rest`, `restructuredtext`) and convert them to html.\n        It leverages the same regex as the [FencedBlockPreprocessor](https://github.com/Python-Markdown/markdown/blob/33359faa385f59b84cd87df5f4b0996055a482e2/markdown/extensions/fenced_code.py#L56-L67)\n        to find the blocks.\n\n        You can also ignore a block from being converted by `rst-in-md` adding\n        `rst-in-md=false` to the attributes: ````{.rst rst-in-md=false}`. You can see an\n        example of this [here](../guides/inline_ignore.md).\n\n        Args:\n            lines (list[str]): List of lines in markdown.\n\n        Returns:\n            list[str]: List of lines in markdown with rst replaced with html.\n        \"\"\"\n        text = \"\\n\".join(lines)\n        processed = \"\"\n        index = 0\n        for match in self.FENCED_BLOCK_RE.finditer(text):\n            lang = None\n            attrs = []\n            classes = []\n            config = {}\n            if match.group(\"lang\") is not None:\n                lang = match.group(\"lang\")\n            elif match.group(\"attrs\") is not None:\n                attrs, remainder = get_attrs_and_remainder(match.group(\"attrs\"))\n                if remainder:  # skip this match due to invalid syntax\n                    warnings.warn(\"Invalid syntax parsing attributes\", stacklevel=1)\n                    processed += text[match.start() : match.end()]\n                    index = match.end()\n                    continue\n                _, classes, config = self.handle_attrs(attrs)\n                if len(classes) &gt; 0:\n                    lang = classes.pop(0)\n\n            processed += text[index : match.start()]\n\n            if lang not in LANGUAGES or config.get(\"rst-in-md\") == \"false\":\n                processed += text[match.start() : match.end()]\n            else:\n                try:\n                    processed += rst_to_soup(match.group(\"code\")).prettify(\n                        formatter=BS4_FORMATTER,\n                    )\n                except ValueError as e:\n                    warnings.warn(str(e), stacklevel=1)\n                    processed += text[match.start() : match.end()]\n\n            index = match.end()\n        processed += text[index:]\n        return processed.split(\"\\n\")\n</code></pre>"},{"location":"reference/extension/#rst_in_md.RestructuredTextInMarkdownPreProcessor.run","title":"<code>run(lines)</code>","text":"<p>Strip restuctured text from markdown and replace it with converted html.</p> <p>This method will look for fenced code blocks in markdown that are marked as restructured text (<code>rst</code>, <code>rest</code>, <code>restructuredtext</code>) and convert them to html. It leverages the same regex as the FencedBlockPreprocessor to find the blocks.</p> <p>You can also ignore a block from being converted by <code>rst-in-md</code> adding <code>rst-in-md=false</code> to the attributes: <code>```{.rst rst-in-md=false}</code>. You can see an example of this here.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>List of lines in markdown.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of lines in markdown with rst replaced with html.</p> Source code in <code>rst_in_md/processor.py</code> <pre><code>def run(self, lines: list[str]) -&gt; list[str]:\n    \"\"\"Strip restuctured text from markdown and replace it with converted html.\n\n    This method will look for fenced code blocks in markdown that are marked as\n    restructured text (`rst`, `rest`, `restructuredtext`) and convert them to html.\n    It leverages the same regex as the [FencedBlockPreprocessor](https://github.com/Python-Markdown/markdown/blob/33359faa385f59b84cd87df5f4b0996055a482e2/markdown/extensions/fenced_code.py#L56-L67)\n    to find the blocks.\n\n    You can also ignore a block from being converted by `rst-in-md` adding\n    `rst-in-md=false` to the attributes: ````{.rst rst-in-md=false}`. You can see an\n    example of this [here](../guides/inline_ignore.md).\n\n    Args:\n        lines (list[str]): List of lines in markdown.\n\n    Returns:\n        list[str]: List of lines in markdown with rst replaced with html.\n    \"\"\"\n    text = \"\\n\".join(lines)\n    processed = \"\"\n    index = 0\n    for match in self.FENCED_BLOCK_RE.finditer(text):\n        lang = None\n        attrs = []\n        classes = []\n        config = {}\n        if match.group(\"lang\") is not None:\n            lang = match.group(\"lang\")\n        elif match.group(\"attrs\") is not None:\n            attrs, remainder = get_attrs_and_remainder(match.group(\"attrs\"))\n            if remainder:  # skip this match due to invalid syntax\n                warnings.warn(\"Invalid syntax parsing attributes\", stacklevel=1)\n                processed += text[match.start() : match.end()]\n                index = match.end()\n                continue\n            _, classes, config = self.handle_attrs(attrs)\n            if len(classes) &gt; 0:\n                lang = classes.pop(0)\n\n        processed += text[index : match.start()]\n\n        if lang not in LANGUAGES or config.get(\"rst-in-md\") == \"false\":\n            processed += text[match.start() : match.end()]\n        else:\n            try:\n                processed += rst_to_soup(match.group(\"code\")).prettify(\n                    formatter=BS4_FORMATTER,\n                )\n            except ValueError as e:\n                warnings.warn(str(e), stacklevel=1)\n                processed += text[match.start() : match.end()]\n\n        index = match.end()\n    processed += text[index:]\n    return processed.split(\"\\n\")\n</code></pre>"},{"location":"reference/superfence/","title":"Superfence","text":"<p>Tip</p> <p>Reference for PyMdown Extensions Superfences can be found here.</p>"},{"location":"reference/superfence/#rst_in_md.superfence_formatter","title":"<code>rst_in_md.superfence_formatter(source, language, css_class, options, md, **kwargs)</code>","text":"<p>Convert superfenced reStructuredText to html.</p> <p>This function will convert the reStructuredText to html using the same method as the standard python markdown extension.</p> <p>Unused Arguments</p> <p>This function is passed a few arguments that are not used. It must adhere to the required signature set by <code>pymdownx.superfences</code>.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Language of the superfence.</p> required <code>language</code> <code>str</code> <p>Language of the superfence (required, but not used).</p> required <code>css_class</code> <code>str</code> <p>CSS class of the superfence (required, but not used).</p> required <code>options</code> <code>dict</code> <p>Options of the superfence (required, but not used).</p> required <code>md</code> <code>Markdown</code> <p>The markdown instance (required, but not used).</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The converted html.</p> Source code in <code>rst_in_md/superfence.py</code> <pre><code>def superfence_formatter(  # noqa: D417\n    source: str,\n    language: str,  # noqa: ARG001\n    css_class: str,  # noqa: ARG001\n    options: dict,  # noqa: ARG001\n    md: Markdown,  # noqa: ARG001\n    **kwargs: dict,  # noqa: ARG001\n) -&gt; str:\n    \"\"\"Convert superfenced reStructuredText to html.\n\n    This function will convert the reStructuredText to html using the same method as\n    the standard python markdown extension.\n\n    !!! note \"Unused Arguments\"\n        This function is passed a few arguments that are not used. It must adhere to\n        [the required signature](https://facelessuser.github.io/pymdown-extensions/extensions/superfences/#formatters)\n        set by `pymdownx.superfences`.\n\n    Args:\n        source (str): Language of the superfence.\n        language (str): Language of the superfence _(required, but not used)_.\n        css_class (str): CSS class of the superfence _(required, but not used)_.\n        options (dict): Options of the superfence _(required, but not used)_.\n        md (Markdown): The markdown instance _(required, but not used)_.\n\n    Returns:\n        str: The converted html.\n    \"\"\"\n    return rst_to_soup(source).prettify(formatter=BS4_FORMATTER)\n</code></pre>"},{"location":"reference/superfence/#rst_in_md.superfence_validator","title":"<code>rst_in_md.superfence_validator(language, inputs, options, attrs, md)</code>","text":"<p>Validate that the superfence should be processed.</p> <p>This function will validate that the superfence should be processed by <code>rst-in-md</code>. This includes:</p> <ul> <li>Checking if the language is supported.</li> <li>Checking if the <code>rst-in-md</code> attribute is set to <code>false</code> or not.</li> <li>Checking if any options or attributes are passed.</li> </ul> <p>Unused Arguments</p> <p><code>md</code> is passed to this function but is not used. It must adhere to the required signature set by <code>pymdownx.superfences</code>.</p> <p>Parameters:</p> Name Type Description Default <code>language</code> <code>str</code> <p>Language of the superfence.</p> required <code>inputs</code> <code>dict</code> <p>All the parsed options/attributes of the superfence.</p> required <code>options</code> <code>dict</code> <p>A dictionary to which all valid options should be assigned to.</p> required <code>attrs</code> <code>dict</code> <p>A dictionary to which all valid attributes should be assigned to.</p> required <code>md</code> <code>Markdown</code> <p>the markdown instance (required, but not used).</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>If the superfence should be processed or not.</p> Source code in <code>rst_in_md/superfence.py</code> <pre><code>def superfence_validator(\n    language: str,\n    inputs: dict,\n    options: dict,\n    attrs: dict,\n    md: Markdown,  # noqa: ARG001\n) -&gt; bool:\n    \"\"\"Validate that the superfence should be processed.\n\n    This function will validate that the superfence should be processed by `rst-in-md`.\n    This includes:\n\n    * Checking if the language is supported.\n    * Checking if the `rst-in-md` attribute is set to `false` or not.\n    * Checking if any options or attributes are passed.\n\n    !!! note \"Unused Arguments\"\n        `md` is passed to this function but is not used. It must adhere to\n        [the required signature](https://facelessuser.github.io/pymdown-extensions/extensions/superfences/#validators)\n        set by `pymdownx.superfences`.\n\n    Args:\n        language (str): Language of the superfence.\n        inputs (dict): All the parsed options/attributes of the superfence.\n        options (dict): A dictionary to which all valid options should be assigned to.\n        attrs (dict): A dictionary to which all valid attributes should be assigned to.\n        md (Markdown): the markdown instance _(required, but not used)_.\n\n    Returns:\n        bool: If the superfence should be processed or not.\n    \"\"\"\n    if language not in LANGUAGES:\n        msg = f\"language '{language}' is not supported.\"\n        logging.error(msg)\n        return False\n\n    allowed = {\"rst-in-md\"}\n    if (keys := set(inputs.keys())) &gt; allowed:\n        msg = f\"keys '{keys - allowed}' are not supported.\"\n        logging.error(msg)\n        return False\n\n    if inputs.get(\"rst-in-md\") == \"false\":\n        logging.info(\"rst-in-md is set to false.\")\n        return False\n\n    if len(options) &gt; 0:\n        logging.error(\"options are not supported.\")\n        return False\n\n    if len(attrs) &gt; 0:\n        logging.error(\"attrs are not supported.\")\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/superfence/#rst_in_md.RestructuredTextInMarkdownAutoConfigurator","title":"<code>rst_in_md.RestructuredTextInMarkdownAutoConfigurator</code>","text":"<p>               Bases: <code>Preprocessor</code></p> <p>Preprocessor to adapt <code>rst-in-md</code> to work with <code>pymdownx.superfences</code>.</p> Source code in <code>rst_in_md/superfence.py</code> <pre><code>class RestructuredTextInMarkdownAutoConfigurator(Preprocessor):\n    \"\"\"Preprocessor to adapt `rst-in-md` to work with `pymdownx.superfences`.\"\"\"\n\n    initialized = False\n\n    def superfences_installed(self) -&gt; bool:\n        \"\"\"Check if the `pymdownx.superfences` extension is installed.\n\n        Returns:\n            bool: If the extension is installed or not.\n        \"\"\"\n        try:\n            from pymdownx.superfences import SuperFencesBlockPreprocessor\n        except ImportError:\n            return False\n\n        return isinstance(\n            self.md.preprocessors[\"fenced_code_block\"],\n            SuperFencesBlockPreprocessor,\n        )\n\n    @staticmethod\n    def construct_fence_config(language: str) -&gt; dict:\n        \"\"\"Create a fence configuration dictionary for `pymdownx.superfences`.\n\n        Create a fence configuration for `pymdownx.superfences` with the given language,\n        in the given [structure](https://github.com/facelessuser/pymdown-extensions/blob/cd7c704487a3a79b6619bfcd0c6af83104d630a8/pymdownx/superfences.py#L273-L276).\n        This configuration will be read by `pymdownx.superfences` to determine how to\n        process the superfence.\n\n        Args:\n            language (str): Language of the superfence.\n\n        Returns:\n            dict: Dictionary of the fence configuration.\n        \"\"\"\n        return {\n            \"name\": language,\n            \"class\": \"rst-in-md\",\n            \"format\": superfence_formatter,\n            \"validator\": superfence_validator,\n        }\n\n    @staticmethod\n    def construct_superfence(language: str) -&gt; dict:\n        \"\"\"Create a superfence dictionary for `pymdownx.superfences`.\n\n        Create a superfence dict for `pymdownx.superfences` with the given language,\n        in the given [structure](https://github.com/facelessuser/pymdown-extensions/blob/cd7c704487a3a79b6619bfcd0c6af83104d630a8/pymdownx/superfences.py#L240-L245).\n        This dictionary will be appended to `SuperFencesCodeExtension().superfences`.\n\n        Args:\n            language (str): Language of the superfence.\n\n        Returns:\n            dict: Dictionary of the superfence for `pymdownx.superfences`.\n\n        Raises:\n            ImportError: pymdown-extensions is not properly installed.\n        \"\"\"\n        try:\n            from pymdownx.superfences import _formatter, _test, _validator\n        except ImportError as e:\n            msg = \"pymdown-extensions is not properly installed.\"\n            raise ImportError(msg) from e\n\n        return {\n            \"name\": language,\n            \"test\": partial(_test, test_language=language),\n            \"formatter\": partial(\n                _formatter,\n                class_name=\"rst-in-md\",\n                _fmt=superfence_formatter,\n            ),\n            \"validator\": partial(\n                _validator,\n                validator=superfence_validator,\n            ),\n        }\n\n    def inject_custom_configs(self) -&gt; None:\n        \"\"\"Add custom fence configs to `pymdownx.superfences`, if not already present.\n\n        Raises:\n            ImportError: pymdown-extensions is not properly installed.\n            ValueError: SuperFencesCodeExtension not found.\n        \"\"\"\n        try:\n            from pymdownx.superfences import SuperFencesCodeExtension\n        except ImportError as e:\n            msg = \"pymdown-extensions is not properly installed.\"\n            raise ImportError(msg) from e\n\n        registered = self.md.registeredExtensions\n        extensions = [e for e in registered if isinstance(e, SuperFencesCodeExtension)]\n        if len(extensions) != 1:\n            msg = \"Unable to find SuperFencesCodeExtension.\"\n            raise ValueError(msg)\n        ext = extensions[0]\n\n        config = self.md.preprocessors[\"fenced_code_block\"].config  # pyright: ignore[reportAttributeAccessIssue]\n        custom_fences = config.get(\"custom_fences\", [])\n        for language in LANGUAGES:\n            if (fence := self.construct_fence_config(language)) not in custom_fences:\n                custom_fences.append(fence)\n                ext.superfences.append(self.construct_superfence(language))\n\n        config[\"custom_fences\"] = custom_fences\n\n    def run(self, lines: list[str]) -&gt; list[str]:\n        \"\"\"Auto-configure `pymdownx.superfences` if installed.\n\n        This method will check if `pymdownx.superfences` is installed. If it is, it will\n        deregister `rst-in-md`, since `pymdownx.superfences` will handle the fenced code\n        blocks. It will also provide the custom fence configurations needed for\n        `pymdownx.superfences` to properly process the fenced code.\n\n        !!! question \"Why is this a preprocessor?\"\n\n            This preprocessor will not actually process any markdown, even if it is\n            called for each markdown file. It much be run after all extensions have been\n            initialized.\n\n        Args:\n            lines (list[str]): Input lines _(required, but not used)_.\n\n        Returns:\n            list[str]: Identical as the input lines.\n        \"\"\"\n        if not self.initialized and self.superfences_installed():\n            self.md.preprocessors.deregister(\"rst-in-md\")\n            self.inject_custom_configs()\n            self.initialized = True\n\n        return lines\n</code></pre>"},{"location":"reference/superfence/#rst_in_md.RestructuredTextInMarkdownAutoConfigurator.construct_fence_config","title":"<code>construct_fence_config(language)</code>  <code>staticmethod</code>","text":"<p>Create a fence configuration dictionary for <code>pymdownx.superfences</code>.</p> <p>Create a fence configuration for <code>pymdownx.superfences</code> with the given language, in the given structure. This configuration will be read by <code>pymdownx.superfences</code> to determine how to process the superfence.</p> <p>Parameters:</p> Name Type Description Default <code>language</code> <code>str</code> <p>Language of the superfence.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the fence configuration.</p> Source code in <code>rst_in_md/superfence.py</code> <pre><code>@staticmethod\ndef construct_fence_config(language: str) -&gt; dict:\n    \"\"\"Create a fence configuration dictionary for `pymdownx.superfences`.\n\n    Create a fence configuration for `pymdownx.superfences` with the given language,\n    in the given [structure](https://github.com/facelessuser/pymdown-extensions/blob/cd7c704487a3a79b6619bfcd0c6af83104d630a8/pymdownx/superfences.py#L273-L276).\n    This configuration will be read by `pymdownx.superfences` to determine how to\n    process the superfence.\n\n    Args:\n        language (str): Language of the superfence.\n\n    Returns:\n        dict: Dictionary of the fence configuration.\n    \"\"\"\n    return {\n        \"name\": language,\n        \"class\": \"rst-in-md\",\n        \"format\": superfence_formatter,\n        \"validator\": superfence_validator,\n    }\n</code></pre>"},{"location":"reference/superfence/#rst_in_md.RestructuredTextInMarkdownAutoConfigurator.construct_superfence","title":"<code>construct_superfence(language)</code>  <code>staticmethod</code>","text":"<p>Create a superfence dictionary for <code>pymdownx.superfences</code>.</p> <p>Create a superfence dict for <code>pymdownx.superfences</code> with the given language, in the given structure. This dictionary will be appended to <code>SuperFencesCodeExtension().superfences</code>.</p> <p>Parameters:</p> Name Type Description Default <code>language</code> <code>str</code> <p>Language of the superfence.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary of the superfence for <code>pymdownx.superfences</code>.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>pymdown-extensions is not properly installed.</p> Source code in <code>rst_in_md/superfence.py</code> <pre><code>@staticmethod\ndef construct_superfence(language: str) -&gt; dict:\n    \"\"\"Create a superfence dictionary for `pymdownx.superfences`.\n\n    Create a superfence dict for `pymdownx.superfences` with the given language,\n    in the given [structure](https://github.com/facelessuser/pymdown-extensions/blob/cd7c704487a3a79b6619bfcd0c6af83104d630a8/pymdownx/superfences.py#L240-L245).\n    This dictionary will be appended to `SuperFencesCodeExtension().superfences`.\n\n    Args:\n        language (str): Language of the superfence.\n\n    Returns:\n        dict: Dictionary of the superfence for `pymdownx.superfences`.\n\n    Raises:\n        ImportError: pymdown-extensions is not properly installed.\n    \"\"\"\n    try:\n        from pymdownx.superfences import _formatter, _test, _validator\n    except ImportError as e:\n        msg = \"pymdown-extensions is not properly installed.\"\n        raise ImportError(msg) from e\n\n    return {\n        \"name\": language,\n        \"test\": partial(_test, test_language=language),\n        \"formatter\": partial(\n            _formatter,\n            class_name=\"rst-in-md\",\n            _fmt=superfence_formatter,\n        ),\n        \"validator\": partial(\n            _validator,\n            validator=superfence_validator,\n        ),\n    }\n</code></pre>"},{"location":"reference/superfence/#rst_in_md.RestructuredTextInMarkdownAutoConfigurator.inject_custom_configs","title":"<code>inject_custom_configs()</code>","text":"<p>Add custom fence configs to <code>pymdownx.superfences</code>, if not already present.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>pymdown-extensions is not properly installed.</p> <code>ValueError</code> <p>SuperFencesCodeExtension not found.</p> Source code in <code>rst_in_md/superfence.py</code> <pre><code>def inject_custom_configs(self) -&gt; None:\n    \"\"\"Add custom fence configs to `pymdownx.superfences`, if not already present.\n\n    Raises:\n        ImportError: pymdown-extensions is not properly installed.\n        ValueError: SuperFencesCodeExtension not found.\n    \"\"\"\n    try:\n        from pymdownx.superfences import SuperFencesCodeExtension\n    except ImportError as e:\n        msg = \"pymdown-extensions is not properly installed.\"\n        raise ImportError(msg) from e\n\n    registered = self.md.registeredExtensions\n    extensions = [e for e in registered if isinstance(e, SuperFencesCodeExtension)]\n    if len(extensions) != 1:\n        msg = \"Unable to find SuperFencesCodeExtension.\"\n        raise ValueError(msg)\n    ext = extensions[0]\n\n    config = self.md.preprocessors[\"fenced_code_block\"].config  # pyright: ignore[reportAttributeAccessIssue]\n    custom_fences = config.get(\"custom_fences\", [])\n    for language in LANGUAGES:\n        if (fence := self.construct_fence_config(language)) not in custom_fences:\n            custom_fences.append(fence)\n            ext.superfences.append(self.construct_superfence(language))\n\n    config[\"custom_fences\"] = custom_fences\n</code></pre>"},{"location":"reference/superfence/#rst_in_md.RestructuredTextInMarkdownAutoConfigurator.run","title":"<code>run(lines)</code>","text":"<p>Auto-configure <code>pymdownx.superfences</code> if installed.</p> <p>This method will check if <code>pymdownx.superfences</code> is installed. If it is, it will deregister <code>rst-in-md</code>, since <code>pymdownx.superfences</code> will handle the fenced code blocks. It will also provide the custom fence configurations needed for <code>pymdownx.superfences</code> to properly process the fenced code.</p> <p>Why is this a preprocessor?</p> <p>This preprocessor will not actually process any markdown, even if it is called for each markdown file. It much be run after all extensions have been initialized.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>Input lines (required, but not used).</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Identical as the input lines.</p> Source code in <code>rst_in_md/superfence.py</code> <pre><code>def run(self, lines: list[str]) -&gt; list[str]:\n    \"\"\"Auto-configure `pymdownx.superfences` if installed.\n\n    This method will check if `pymdownx.superfences` is installed. If it is, it will\n    deregister `rst-in-md`, since `pymdownx.superfences` will handle the fenced code\n    blocks. It will also provide the custom fence configurations needed for\n    `pymdownx.superfences` to properly process the fenced code.\n\n    !!! question \"Why is this a preprocessor?\"\n\n        This preprocessor will not actually process any markdown, even if it is\n        called for each markdown file. It much be run after all extensions have been\n        initialized.\n\n    Args:\n        lines (list[str]): Input lines _(required, but not used)_.\n\n    Returns:\n        list[str]: Identical as the input lines.\n    \"\"\"\n    if not self.initialized and self.superfences_installed():\n        self.md.preprocessors.deregister(\"rst-in-md\")\n        self.inject_custom_configs()\n        self.initialized = True\n\n    return lines\n</code></pre>"},{"location":"reference/superfence/#rst_in_md.RestructuredTextInMarkdownAutoConfigurator.superfences_installed","title":"<code>superfences_installed()</code>","text":"<p>Check if the <code>pymdownx.superfences</code> extension is installed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>If the extension is installed or not.</p> Source code in <code>rst_in_md/superfence.py</code> <pre><code>def superfences_installed(self) -&gt; bool:\n    \"\"\"Check if the `pymdownx.superfences` extension is installed.\n\n    Returns:\n        bool: If the extension is installed or not.\n    \"\"\"\n    try:\n        from pymdownx.superfences import SuperFencesBlockPreprocessor\n    except ImportError:\n        return False\n\n    return isinstance(\n        self.md.preprocessors[\"fenced_code_block\"],\n        SuperFencesBlockPreprocessor,\n    )\n</code></pre>"}]}